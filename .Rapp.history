library(igraph)
??license
licence("igraph")
licence(igraph)
license(igraph)
license("igraph")
license()
?igraph
rm(list=ls())#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")
rm(list=ls())#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)
source("scripts0/0_1_graph_generation.R")
load("data/data0a.Rdata")
source("scripts0/0_2_subgraph_generation.R")
load("/Users/yrochat/Dropbox/DHLab/phd_thesis/data/data0a.Rdata")
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components
source("scripts0/0_1_graph_generation.R")
source("scripts0/0_2_subgraph_generation.R")
source("scripts0/0_3_subgraph_chapters.R")
source("scripts0/0_4_layout_generation.R")
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS
source("init/0_1_graph_generation.R")
source("init/0_2_subgraph_generation.R")
source("init/0_3_subgraph_chapters.R")
source("init/0_4_layout_generation.R")
source("init/0_5_contraction.R")
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS
source("init/0_1_graph_generation.R")
source("init/0_2_subgraph_generation.R")
source("init/0_3_subgraph_chapters.R")
source("init/0_4_layout_generation.R")
source("init/0_5_contraction.R")
##############################
### All plot nodes as one ####
##############################
#
noms.complot <- c("Louise d'Épinay", "Grimm", "Diderot", "Baron d'Holbach", "d'Alembert", "Boufflers-Rouverel" #, "Choiseul", "Tronchin", "Voltaire"#
)#
#
# complot <- sapply(noms.complot, function(x) grep(x, V(g)$name))#
# noms.complet <- V(g)[complot]$name#
#
# grep("Voltaire", V(g)$name)#
# grep("Tronchin", V(g)$name)#
#
# contract.vertices : doesn't really work, result is weird#
#
### We should build the network from scratch !#
### and keep the layout !
##############################
### All plot nodes as one ####
##############################
#
noms.complot <- c("Louise d'Épinay", "Grimm", "Diderot", "Baron d'Holbach", "d'Alembert", "Boufflers-Rouverel" #, "Choiseul", "Tronchin", "Voltaire"#
)#
#
# complot <- sapply(noms.complot, function(x) grep(x, V(g)$name))#
# noms.complet <- V(g)[complot]$name#
#
# grep("Voltaire", V(g)$name)#
# grep("Tronchin", V(g)$name)#
#
# contract.vertices : doesn't really work, result is weird#
#
### We should build the network from scratch !#
### and keep the layout !#
#
########################################
### Création du graphe FINAL ajusté ####
########################################
#
### ATTENTION cette méthode fait la contraction avant la projection du graphe, ce qui fait qu'il y a tout d'un coup quelques personnes connectées au noeud contracté qui ne le sont pas sinon.#
#
hey <- sapply(noms.complot, function(x) grep(x, confessions$full))#
# contrôle :#
# for (i in 1:length(hey)) print(confessions[hey[[i]],])#
#
hey2 <- do.call(c, hey)#
names(hey2) <- NULL#
#
confessions3 <- confessions#
confessions3$full[hey2] <- "Schemers"#
#
confessions2 <- confessions1 <- confessions3
confessions1$page1 <- paste(sprintf("%03d",confessions$page-1, sep=""), sprintf("%03d",confessions$page, sep=""), sep="")#
#
# toutes les pages n des confessions sont transformées en page n,n+1#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions2$page1 <- paste(sprintf("%03d",confessions$page, sep=""), sprintf("%03d",confessions$page+1, sep=""), sep="")#
#
input <- rbind(confessions1[,c(5,2,3,4)],confessions2[,c(5,2,3,4)])#
#
# Le nombre de duplicata#
# sum(duplicated(input))#
#
# cette ligne c'est si on veut pas compter double pour les co-occurrences même page#
# mais ça fait tomber drastiquement le nombre de sommets !!!#
#
input <- input[!duplicated(input[,1:2]),]
gx.bip <- graph.data.frame(input, directed=FALSE)							# La création du graphe (qui est biparti, du coup)#
V(gx.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(gx.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj2 #
gx <- subgraph.edges(gx, E(gx)[weight>2])#
gx <- delete.vertices(gx, v = V(gx)[clusters(gx)$membership != 1])#
#
rm(confessions1, confessions2, confessions3, input)#
#
V(gx)$id <- 1:vcount(gx)
temp.layout <- g1$layout[V(g1)$name %in% V(gx)$name,]#
#
# où sont les complotistes : grep("Schemers", V(gx)$name)#
gx$layout <- rbind(temp.layout[1:(grep("Schemers", V(gx)$name)-1),], c(1,0), temp.layout[grep("Schemers", V(gx)$name):nrow(temp.layout),])#
#
# tkplot(gx)#
# tkplot(g)
V(gx)
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS ####
#############################################
#
# source("init/0_1_graph_generation.R")#
load("data/data0a.Rdata")#
#
################################
### GENERATION OF SUBGRAPHS ####
################################
#
# source("init/0_2_subgraph_generation.R")#
load("data/data0b.Rdata")#
#
#############################################
### GENERATION OF SUBGRAPHS PER CHAPTERS ####
#############################################
#
# source("init/0_3_subgraph_chapters.R")#
load("data/data0c.Rdata")#
#
###############################################
### GENERATION OF LAYOUT FOR THE SUBGRAPHS ####
###############################################
#
# source("init/0_4_layout_generation.R")#
load("data/data0z.Rdata")
##############################
### All plot nodes as one ####
##############################
#
noms.complot <- c("Louise d'Épinay", "Grimm", "Diderot", "Baron d'Holbach", "d'Alembert", "Boufflers-Rouverel" #, "Choiseul", "Tronchin", "Voltaire"#
)#
#
# complot <- sapply(noms.complot, function(x) grep(x, V(g)$name))#
# noms.complet <- V(g)[complot]$name#
#
# grep("Voltaire", V(g)$name)#
# grep("Tronchin", V(g)$name)#
#
# contract.vertices : doesn't really work, result is weird#
#
### We should build the network from scratch !#
### and keep the layout !#
#
########################################
### Création du graphe FINAL ajusté ####
########################################
#
### ATTENTION cette méthode fait la contraction avant la projection du graphe, ce qui fait qu'il y a tout d'un coup quelques personnes connectées au noeud contracté qui ne le sont pas sinon.#
#
hey <- sapply(noms.complot, function(x) grep(x, confessions$full))#
# contrôle :#
# for (i in 1:length(hey)) print(confessions[hey[[i]],])#
#
hey2 <- do.call(c, hey)#
names(hey2) <- NULL#
#
confessions3 <- confessions#
confessions3$full[hey2] <- "Schemers"#
#
confessions2 <- confessions1 <- confessions3#
#
# toutes les pages n des confessions sont transformées en page n-1,n#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions1$page1 <- paste(sprintf("%03d",confessions$page-1, sep=""), sprintf("%03d",confessions$page, sep=""), sep="")#
#
# toutes les pages n des confessions sont transformées en page n,n+1#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions2$page1 <- paste(sprintf("%03d",confessions$page, sep=""), sprintf("%03d",confessions$page+1, sep=""), sep="")#
#
input <- rbind(confessions1[,c(5,2,3,4)],confessions2[,c(5,2,3,4)])#
#
# Le nombre de duplicata#
# sum(duplicated(input))#
#
# cette ligne c'est si on veut pas compter double pour les co-occurrences même page#
# mais ça fait tomber drastiquement le nombre de sommets !!!#
#
input <- input[!duplicated(input[,1:2]),]#
#
gx.bip <- graph.data.frame(input, directed=FALSE)
gx.bip
V(gx.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(gx.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages
V(gx.bip)$types
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj2 #
gx <- subgraph.edges(gx, E(gx)[weight>2])#
gx <- delete.vertices(gx, v = V(gx)[clusters(gx)$membership != 1])
gx
gx.bip <- graph.data.frame(input, directed=FALSE)							# La création du graphe (qui est biparti, du coup)#
V(gx.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(gx.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages
gx.bip
bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj2
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj2
subgraph.edges(gx, E(gx)[weight>2])
gx <- subgraph.edges(gx, E(gx)[weight>2])
clusters(gx)$membership
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj2 #
gx <- subgraph.edges(gx, E(gx)[weight>2])
V(gx)
V(gx.bip)
V(gx.bip)$types
gx.bip <- graph.data.frame(input, directed=FALSE)							# La création du graphe (qui est biparti, du coup)#
V(gx.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(gx.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages#
#
# On fait la projection sur les noeuds FALSE, c'est-à-dire que deux#
# personnages sont liés s'ils étaient connectés dans le graphe biparti#
# à la même page des Confessions#
#
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj2
V(gx)
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj1
gx
V(gx)
gx <- subgraph.edges(gx, E(gx)[weight>2])
gx
gx <- delete.vertices(gx, v = V(gx)[clusters(gx)$membership != 1])
gx
rm(confessions1, confessions2, confessions3, input)#
#
V(gx)$id <- 1:vcount(gx)#
#
# les sommets : V(g1)$name[V(g1)$name %in% V(gx)$name]#
# on prend leurs coordonnées#
temp.layout <- g1$layout[V(g1)$name %in% V(gx)$name,]#
#
# où sont les complotistes : grep("Schemers", V(gx)$name)#
gx$layout <- rbind(temp.layout[1:(grep("Schemers", V(gx)$name)-1),], c(1,0), temp.layout[grep("Schemers", V(gx)$name):nrow(temp.layout),])#
#
# tkplot(gx)#
# tkplot(g)#
#
# gx$layout <- layout.norm(tkplot.getcoords(8), xmin = -1, xmax = 1, ymin = -1, ymax = 1)#
#
#############
### PLOT ####
#############
#
clusters(gx)#
#
V(gx)$size <- .5 + log2(degree(gx)+1)#
V(gx)$color <- "gray99"#
#
V(gx)$color[grep("Schemers", V(gx)$name)] <- "grey70"#
#
V(gx)$frame.color <- "black"#
V(gx)$shape <- "fcircle"#
V(gx)$frame.width <- 1#
V(gx)$label <- ""#
V(gx)$label.cex <- .5#
#
E(gx)$width <- .5#
E(gx)$color <- "gray10"#
#
E(gx)[from("Schemers")]$color <- "grey70"#
#
pdf("~/Dropbox/sharelatex/my_thesis/figs/ch5/contraction.pdf")#
par(mar = c(0,0,0,0))#
plot(gx)#
dev.off()	#
##################################################################################################################################
save(	gx, #
		file="data/data0y.Rdata") ####
##################################################################################################################################
# # #
# pdf("g1.pdf")#
# plot(g1, vertex.label = "", vertex.size = .5, rescale = FALSE)#
# dev.off()#
#
# pdf("g.pdf")#
# plot(g, vertex.label = "", vertex.size = .5, rescale = FALSE)#
# dev.off()#
#
# pdf("gx.pdf")#
# plot(gx, vertex.label = "", vertex.size = .5, rescale = FALSE)#
# dev.off()
source("scripts/9_vertex_frame_width.R")
source("init/vertex_frame_width.R")
source("init/0_5_contraction.R")
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# to modify the vertex frame width : use "fcircle" as shape#
source("init/vertex_frame_width.R")#
#
# Here is what we obtain after executing "main0.R"#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS ####
#############################################
#
# source("init/0_1_graph_generation.R")#
load("data/data0a.Rdata")#
#
################################
### GENERATION OF SUBGRAPHS ####
################################
#
# source("init/0_2_subgraph_generation.R")#
load("data/data0b.Rdata")#
#
#############################################
### GENERATION OF SUBGRAPHS PER CHAPTERS ####
#############################################
#
# source("init/0_3_subgraph_chapters.R")#
load("data/data0c.Rdata")#
#
###############################################
### GENERATION OF LAYOUT FOR THE SUBGRAPHS ####
###############################################
#
# source("init/0_4_layout_generation.R")#
load("data/data0z.Rdata")#
#
#################################################
### GENERATION OF THE PLOT CONTRACTION GRAPH
source("init/0_5_contraction.R")
##############################
### All plot nodes as one ####
##############################
#
noms.complot <- c("Louise d'Épinay", "Grimm", "Diderot", "Baron d'Holbach", "d'Alembert", "Boufflers-Rouverel" #, "Choiseul", "Tronchin", "Voltaire"#
)#
#
# complot <- sapply(noms.complot, function(x) grep(x, V(g)$name))#
# noms.complet <- V(g)[complot]$name#
#
# grep("Voltaire", V(g)$name)#
# grep("Tronchin", V(g)$name)#
#
# contract.vertices : doesn't really work, result is weird#
#
### We should build the network from scratch !#
### and keep the layout !#
#
########################################
### Création du graphe FINAL ajusté ####
########################################
#
### ATTENTION cette méthode fait la contraction avant la projection du graphe, ce qui fait qu'il y a tout d'un coup quelques personnes connectées au noeud contracté qui ne le sont pas sinon.#
#
hey <- sapply(noms.complot, function(x) grep(x, confessions$full))#
# contrôle :#
# for (i in 1:length(hey)) print(confessions[hey[[i]],])#
#
hey2 <- do.call(c, hey)#
names(hey2) <- NULL#
#
confessions3 <- confessions#
confessions3$full[hey2] <- "Schemers"#
#
confessions2 <- confessions1 <- confessions3
# toutes les pages n des confessions sont transformées en page n-1,n#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions1$page1 <- paste(sprintf("%03d",confessions$page-1, sep=""), sprintf("%03d",confessions$page, sep=""), sep="")#
#
# toutes les pages n des confessions sont transformées en page n,n+1#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions2$page1 <- paste(sprintf("%03d",confessions$page, sep=""), sprintf("%03d",confessions$page+1, sep=""), sep="")#
#
input <- rbind(confessions1[,c(5,2,3,4)],confessions2[,c(5,2,3,4)])#
#
# Le nombre de duplicata#
# sum(duplicated(input))#
#
# cette ligne c'est si on veut pas compter double pour les co-occurrences même page#
# mais ça fait tomber drastiquement le nombre de sommets !!!#
#
input <- input[!duplicated(input[,1:2]),]#
#
gx.bip <- graph.data.frame(input, directed=FALSE)							# La création du graphe (qui est biparti, du coup)#
V(gx.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(gx.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages#
#
# On fait la projection sur les noeuds FALSE, c'est-à-dire que deux#
# personnages sont liés s'ils étaient connectés dans le graphe biparti#
# à la même page des Confessions#
#
gx <- bipartite.projection(gx.bip, type=V(gx.bip)$types, multiplicity = TRUE)$proj1 #
gx <- subgraph.edges(gx, E(gx)[weight>2])#
gx <- delete.vertices(gx, v = V(gx)[clusters(gx)$membership != 1])
gx
rm(confessions1, confessions2, confessions3, input)
V(gx)$id <- 1:vcount(gx)
V(gx)$id
V(gx)
temp.layout <- g1$layout[V(g1)$name %in% V(gx)$name,]
rbind(temp.layout[1:(grep("Schemers", V(gx)$name)-1),], c(1,0), temp.layout[grep("Schemers", V(gx)$name):nrow(temp.layout),])
temp.layout
g1$layout[V(g1)$name %in% V(gx)$name,]
ls()
g1
g1$layout
V(g1)$name
V(gx)$name
# Importing and reading table#
# of IDs and APPEARING PAGES#
res.df <- read.table(	"init/apparitions_par_pages.txt", #
						sep="\t", #
						stringsAsFactors = FALSE,#
						col.names = c("id", "volume", "page", "externe"))#
head(res.df)#
#
# $externe takes as values "n" or nothing.#
# In the "n" case, interpretation is that the name appears in the footnotes.#
# Watch out ! Names appearing in theoretical introductions or essays#
# won't be denoted with "n". The texts under scope have to be cut#
# from the first to the last page.#
#
# Cette fois on lit les noms des personnes citées#
res <- readLines("init/names.txt")#
#
res <- strsplit(res, split = "\t")#
res.df2 <- do.call(rbind, res)#
res.df2 <- as.data.frame(res.df2, stringsAsFactors = FALSE)#
#
colnames(res.df2) <- c("id", "full")#
#
# On transpose les noms des sommets dans le tableau des occurrences !!! Peut être très long !#
res <- merge(res.df, res.df2, by.x = "id", by.y = "id")#
#
# On va supprimer les noms des intervenants extérieurs à l'histoire#
res <- res[!(res$externe == "n"),]#
#
relations <- res#
#
####################
### BASIC STATS ####
####################
#
# Combien de personnages dans la table#
length(unique(res.df2$full))#
#
# Combien de personnages cités dans les commentaires ou footnotes#
length(unique(res.df$id[res.df$externe == "n"]))#
#
# Combien de personnages cités par Rousseau#
length(unique(res.df$id[res.df$externe == ""]))#
#
################################
### FICHIER DES CONFESSIONS ####
################################
# Pour tout afficher dans l'ordre#
##
# relations[order(relations$volume, relations$page),]#
#
confessions <- relations[which((relations$volume == 1 & relations$page >= 65) | (relations$volume == 2 & relations$page <= 847)),]						# On extrait uniquement les Confessions#
#
# chapitrage#
livres <- data.frame(	page=65:847, #
						type=c(#
							"intro1",					# page 65, aucun nom n'apparaît sur cette page !#
							"vide",						# page 66#
							rep("1",length(67:115)),#
							"vide",						# page 116#
							rep("2",length(117:167)),#
							"vide",						# page 168#
							rep("3",length(169:220)),#
							rep("4",length(221:269)),#
							"vide",						# page 270#
							rep("5",length(271:326)),#
							rep("6",length(327:380)),#
							"intro2",					# page 381, #
							"vide",						# page 382#
							rep("7",length(383:471)),#
							"vide",						# page 472#
							rep("8",length(473:538)),#
							rep("9",length(539:637)),#
							"vide",						# page 638#
							rep("10",length(639:704)),#
							rep("11",length(705:758)),#
							rep("12",length(759:847))#
							), stringsAsFactors = FALSE)#
#
confessions <- merge(confessions, livres, by.x = "page", by.y = "page")#
#
confessions <- confessions[,c(1,5,6,2)]									# pour que nom et numéro de page apparaissent dans le bon ordre#
#
####################
### BASIC STATS ####
####################
#
# Combien de personnages dans les Confessions#
length(unique(confessions$full))#
################################
### Création du graphe NAIF ####
################################
#
# toutes les versions 0 des graphes correspondent aux graphes dont la co-occurrence est sur la page, sans les pages adjacentes#
#
# Ici le graphe biparti#
g0.bip <- graph.data.frame(confessions, directed=FALSE)#
V(g0.bip)$types <- FALSE#
V(g0.bip)[1:length(unique(confessions$page))]$types <- TRUE#
#
# Ici le graphe projeté#
g0 <- bipartite.projection(g0.bip, type=V(g0.bip)$types, multiplicity = TRUE)$proj2 #
#################################
### Création du graphe FINAL ####
#################################
#
confessions2 <- confessions1 <- confessions#
#
# toutes les pages n des confessions sont transformées en page n-1,n#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions1$page1 <- paste(sprintf("%03d",confessions$page-1, sep=""), sprintf("%03d",confessions$page, sep=""), sep="")#
#
# toutes les pages n des confessions sont transformées en page n,n+1#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions2$page1 <- paste(sprintf("%03d",confessions$page, sep=""), sprintf("%03d",confessions$page+1, sep=""), sep="")#
#
input <- rbind(confessions1[,c(5,2,3,4)],confessions2[,c(5,2,3,4)])#
#
# Le nombre de duplicata#
# sum(duplicated(input))#
#
# cette ligne c'est si on veut pas compter double pour les co-occurrences même page#
# mais ça fait tomber drastiquement le nombre de sommets !!!#
input <- unique(input)#
#
g1.bip <- graph.data.frame(input, directed=FALSE)							# La création du graphe (qui est biparti, du coup)#
V(g1.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(g1.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages#
#
# Pour se faire une idée de la taille des noms des gens#
# nchar(V(g)[types == FALSE]$name)#
#
# On fait la projection sur les noeuds FALSE, c'est-à-dire que deux#
# personnages sont liés s'ils étaient connectés dans le graphe biparti#
# à la même page des Confessions#
#
g1 <- bipartite.projection(g1.bip, type=V(g1.bip)$types, multiplicity = TRUE)$proj2
g1
V(g1)
# Importing and reading table#
# of IDs and APPEARING PAGES#
res.df <- read.table(	"init/apparitions_par_pages.txt", #
						sep="\t", #
						stringsAsFactors = FALSE,#
						col.names = c("id", "volume", "page", "externe"))#
head(res.df)#
#
# $externe takes as values "n" or nothing.#
# In the "n" case, interpretation is that the name appears in the footnotes.#
# Watch out ! Names appearing in theoretical introductions or essays#
# won't be denoted with "n". The texts under scope have to be cut#
# from the first to the last page.#
#
# Cette fois on lit les noms des personnes citées#
res <- readLines("init/names.txt")#
#
res <- strsplit(res, split = "\t")#
res.df2 <- do.call(rbind, res)#
res.df2 <- as.data.frame(res.df2, stringsAsFactors = FALSE)#
#
colnames(res.df2) <- c("id", "full")#
#
# On transpose les noms des sommets dans le tableau des occurrences !!! Peut être très long !#
res <- merge(res.df, res.df2, by.x = "id", by.y = "id")#
#
# On va supprimer les noms des intervenants extérieurs à l'histoire#
res <- res[!(res$externe == "n"),]#
#
relations <- res#
#
####################
### BASIC STATS ####
####################
#
# Combien de personnages dans la table#
length(unique(res.df2$full))#
#
# Combien de personnages cités dans les commentaires ou footnotes#
length(unique(res.df$id[res.df$externe == "n"]))#
#
# Combien de personnages cités par Rousseau#
length(unique(res.df$id[res.df$externe == ""]))#
#
################################
### FICHIER DES CONFESSIONS ####
################################
# Pour tout afficher dans l'ordre#
##
# relations[order(relations$volume, relations$page),]#
#
confessions <- relations[which((relations$volume == 1 & relations$page >= 65) | (relations$volume == 2 & relations$page <= 847)),]						# On extrait uniquement les Confessions#
#
# chapitrage#
livres <- data.frame(	page=65:847, #
						type=c(#
							"intro1",					# page 65, aucun nom n'apparaît sur cette page !#
							"vide",						# page 66#
							rep("1",length(67:115)),#
							"vide",						# page 116#
							rep("2",length(117:167)),#
							"vide",						# page 168#
							rep("3",length(169:220)),#
							rep("4",length(221:269)),#
							"vide",						# page 270#
							rep("5",length(271:326)),#
							rep("6",length(327:380)),#
							"intro2",					# page 381, #
							"vide",						# page 382#
							rep("7",length(383:471)),#
							"vide",						# page 472#
							rep("8",length(473:538)),#
							rep("9",length(539:637)),#
							"vide",						# page 638#
							rep("10",length(639:704)),#
							rep("11",length(705:758)),#
							rep("12",length(759:847))#
							), stringsAsFactors = FALSE)#
#
confessions <- merge(confessions, livres, by.x = "page", by.y = "page")#
#
confessions <- confessions[,c(1,5,6,2)]									# pour que nom et numéro de page apparaissent dans le bon ordre#
#
####################
### BASIC STATS ####
####################
#
# Combien de personnages dans les Confessions#
length(unique(confessions$full))#
################################
### Création du graphe NAIF ####
################################
#
# toutes les versions 0 des graphes correspondent aux graphes dont la co-occurrence est sur la page, sans les pages adjacentes#
#
# Ici le graphe biparti#
g0.bip <- graph.data.frame(confessions, directed=FALSE)#
V(g0.bip)$types <- FALSE#
V(g0.bip)[1:length(unique(confessions$page))]$types <- TRUE#
#
# Ici le graphe projeté#
g0 <- bipartite.projection(g0.bip, type=V(g0.bip)$types, multiplicity = TRUE)$proj2 #
#################################
### Création du graphe FINAL ####
#################################
#
confessions2 <- confessions1 <- confessions#
#
# toutes les pages n des confessions sont transformées en page n-1,n#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions1$page1 <- paste(sprintf("%03d",confessions$page-1, sep=""), sprintf("%03d",confessions$page, sep=""), sep="")#
#
# toutes les pages n des confessions sont transformées en page n,n+1#
# l'opération se fait pour chaque entrée du tableau "confessions"#
confessions2$page1 <- paste(sprintf("%03d",confessions$page, sep=""), sprintf("%03d",confessions$page+1, sep=""), sep="")#
#
input <- rbind(confessions1[,c(5,2,3,4)],confessions2[,c(5,2,3,4)])#
#
# Le nombre de duplicata#
# sum(duplicated(input))#
#
# cette ligne c'est si on veut pas compter double pour les co-occurrences même page#
# mais ça fait tomber drastiquement le nombre de sommets !!!#
input <- unique(input)#
#
g1.bip <- graph.data.frame(input, directed=FALSE)							# La création du graphe (qui est biparti, du coup)#
V(g1.bip)$types <- FALSE													# On donne l'étiquette FALSE aux personnages#
V(g1.bip)[1:length(unique(input$page))]$types <- TRUE						# On donne l'étiquette TRUE aux pages#
#
# Pour se faire une idée de la taille des noms des gens#
# nchar(V(g)[types == FALSE]$name)#
#
# On fait la projection sur les noeuds FALSE, c'est-à-dire que deux#
# personnages sont liés s'ils étaient connectés dans le graphe biparti#
# à la même page des Confessions#
#
g1 <- bipartite.projection(g1.bip, type=V(g1.bip)$types, multiplicity = TRUE)$proj1 #
#
rm(confessions1, confessions2, input, relations, res, res.df, res.df2)#
#
V(g1)$id <- 1:vcount(g1)#
#
g1$layout <- layout.norm(layout.fruchterman.reingold(g1, repulserad = vcount(g1)^2.5, niter = 1000), -1, 1, -1, 1)#
g0$layout <- g1$layout#
##################################################################################################################################
save(	g0, g1,#
		g0.bip, g1.bip,#
		confessions, livres, #
		file="data/data0a.Rdata")
g0
g1
V(g1)
source("init/0_2_subgraph_generation.R")
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# to modify the vertex frame width : use "fcircle" as shape#
source("init/vertex_frame_width.R")#
#
# Here is what we obtain after executing "main0.R"#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS
source("init/0_1_graph_generation.R")
ls()
V(g0)
V(g1)
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# to modify the vertex frame width : use "fcircle" as shape#
source("init/vertex_frame_width.R")#
#
# Here is what we obtain after executing "main0.R"#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS
source("init/0_1_graph_generation.R")
ls()
V(g0)
V(g1)
ls()
source("init/0_2_subgraph_generation.R")
ls()
V(g22)
source("init/0_3_subgraph_chapters.R")
ls()
source("init/0_4_layout_generation.R")
ls()
source("init/0_5_contraction.R")
ls()
gx
V(g)
V(gx)
# please see https://github.com/yrochat/phd_thesis/blob/master/README.md before first use#
#
# this command will delete everything in your working space#
#
rm(list=ls())#
#
# choose any working directory#
# everything is stocked inside : data and scripts#
#
setwd("~/Dropbox/DHLab/PhD_thesis/")#
#
library(igraph)#
library(xtable)#
library(ggplot2)#
library(scales)#
library(RColorBrewer)#
library(gridExtra)#
#
# to modify the vertex frame width : use "fcircle" as shape#
source("init/vertex_frame_width.R")#
#
# Here is what we obtain after executing "main0.R"#
#
# g 				# final graph : giant component of g3#
#
# g1  	 			# bipartite graph with co-occurrences +/- 1#
# g1.id	 			# projected on nodes #
# g1.id.list		# list of projections with varying thresholds#
# sub.g1.id.list	# corresponding giant components#
#
# g0				# bipartite graph with page co-occurrences#
# g0.id				# projected on nodes#
# g0.id.list		# list of projections with varying thresholds#
# sub.g0.id.list	# corresponding giant components#
#############################################
### GENERATION OF NAIVE AND FINAL GRAPHS ####
#############################################
#
# source("init/0_1_graph_generation.R")#
load("data/data0a.Rdata")#
#
################################
### GENERATION OF SUBGRAPHS ####
################################
#
# source("init/0_2_subgraph_generation.R")#
load("data/data0b.Rdata")#
#
#############################################
### GENERATION OF SUBGRAPHS PER CHAPTERS ####
#############################################
#
# source("init/0_3_subgraph_chapters.R")#
load("data/data0c.Rdata")#
#
###############################################
### GENERATION OF LAYOUT FOR THE SUBGRAPHS ####
###############################################
#
# source("init/0_4_layout_generation.R")#
load("data/data0z.Rdata")#
#
#################################################
### GENERATION OF THE PLOT CONTRACTION GRAPH ####
#################################################
#
# source("init/0_5_contraction.R")#
load("data/data0y.Rdata")#
# this is for the initialisation/loading#
# then for the visulisation/analysis comes "main.R"
ls()
confessoins
confessions
ls()
g0
g0.bip
gchap
livres
ls()
sub.g0.list
